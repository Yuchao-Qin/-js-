<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
         function Person (name,age,job) {
            this.name = name;
            this.age = age;
            this.job = job;
            }
            Person.prototype.name1 = 'qyc';    //prototype 相当于抽象出来的全局对象，构造函数的每一个属性都可以访问prototype中的值。
            Person.prototype.age1 = '22';      // 每一个函数都有一个prototype属性，prototype 里面有一个constructor属性又指回person
            Person.prototype.job = 'programer';
            Person.prototype.fn = function () {
                console.log(this.age+1)
            }
        

            var person1 = new Person('chy','26','doctor')
            person1.fn()
            console.log(person1.name1)
            console.log(person1)              //每个构造函数的实例 都有一个 __proto__ 属性 ，指向构造函数的原型而不是构造函数
            console.dir(Person)
            console.log(Object.getPrototypeOf(person1))  // 获取 person1 的  __proto__,也就是构造函数的原型
            console.log(Person.prototype.isPrototypeOf(person1))   //  判断  person1 是否是 Person 的实例 ，返回布尔值。
            console.log(person1.hasOwnProperty('name1'))   //hasOwnProperty 属性在对象的实例中返回true 属性在实例的原型中返回false
            console.log(person1.hasOwnProperty('name'))
            console.log(Person.prototype.isPrototypeOf(person1))   //实例中的[[prototype]] 是否指向构造函数的原型
            
                

            delete person1.name1
            delete person1.name
            console.log(person1)
            //delete 只能删除 实例中的属性，不能删除原型中的属性
            
    </script>
</body>
</html>




